# Code Complete v2

[TOC]

- p57:
  - “迷信” 指的是你对代码的感觉代替对代码的理解｡
  - 如果你不知道为什么它是有效的,那就研究并讨论它,或者用替代方案重新实现一次,直到你弄明白为止｡
- p59:
  - 程序中参数个数的合理上限应该是七个左右｡

## 5 高质量子程序特点

### 5.1  生成子程序的原因

1. 降低复杂性
2. 避免代码重复
3. 减少改动带来的影响
4. 隐含顺序: PopStack() 决定顺序
5. 方便改进性能
6. 集中控制
7. 隐藏数据结构
8. 隐藏操作指针
9. 隐藏全局变量: 鼓励思考数据是不是全局的
10. 提高可移植性
11. 分隔复杂操作
12. 方便测试简单

- 简单的程序也可以放到子程序中
  - 如  `(x = a + (b/c), c != 0);` 的实现, 可以用带有具体意义的函数名包装

### 5.2 子程序名称恰当

- 强调过程: PrintReport(), CheckotDerInfo()
- 面向对象: Report.Print(), OrderInfo.Check()
- 强调返回值的名字:Cos(), PrinterReady(), CurrentTime(),

- 区分不同操作:
  - `Get`InputChar(): 将清除输入缓冲区
  - `Query`InputChar(): 不清除

### 5.3 强内聚性

单一职责原则的子程序更不容易出错

#### 5.3.1 好的内聚

- 功能内聚:Sin(), GetXXName(), EraseFile()
- 顺序内聚: 比如文件操作:
  - 打开,读,逻辑操作,输出结果,关闭文件
    - 这时候拆开就没有意义
  - 如果命名困难,可以考虑改用`功能内聚`
- 通讯内聚: GetNameAndChangePhoneNumber(), 一定程度上可以接受
- 临时内聚: Startup(), Shutdown(),
  - 如 Startup(): 读配置文件,初始化临时文件,建立内存管理
    - 可以做几个子程序让Startup() 调用, 而不是自己完成.

#### 5.3.2 不好的内聚

- 过程内聚: 多个可以`功能内聚`的代码集合
- 逻辑内聚: 通过传入一个`控制标志`来决定子程序处理的内容
  - 如果函数只是充当`事务处理中心`, 那是可以接受的(如 rust 的 `match`)

#### 5.3.3 内聚举例

- 功能内聚: 计算年龄和退休时间
  - 函数①: 根据 `生日` 计算年龄
  - 函数②: 根据`函数①`的结果, 再计算退休时间

`不要忘了问题的关键不是争论它具有哪种不好的内聚性，而是如何改善其内聚性`

### 5.4 松散耦合性

[ 耦合 != 内聚 ], 耦合指的是两个子程序之间的紧密程度

#### 5.4.1 耦合标准

- 耦合规模: 越小越好, 越松散越好
- 密切程度: 判断标准: 两个子程序中的参数
- 可见性:
  - 参数传递是明显的 => :+1:
  - 修改隐藏的参数 (全局参数) => :-1:
- 灵活性: `指改变两个子程序之间联系的容易程度`

`简而言之，如果一个子程序越容易被其它子程序调用，那么它的耦合程度也就越低。这样 的好处是可以增强灵活性和维护性`

#### 5.4.2 耦合层次

- 简单数据耦合: 只传基础数据类型
- 数据结构耦合: 传结构体的
- 控制耦合: 传控制信号的, 通常不太好
- 全局数据耦合: 如果数据是`只读的`还可以忍受. 但还是不受欢迎, 因为`全局变量和调用者的联系`总是容易被遗忘的
- 不合理耦合(pathological): `如果一个子程序使用了另外一个子程序中代码，或者它改变了其中的局部变量，那么它们就是不合理耦合`

#### 5.4.3 耦合举例

- 简单的: Sin(), GetName()
- 可接受的数据结构: 把 [含有 5 个 field 的结构体] 传到另一个子程序中, 并使用全部的 field.
- 不可接受的数据结构: 只使用了其中两个 field, 但是还是传了整个结构体, 这不好
- 有问题的数据结构耦合:
  - 一个有 27 个 field 的结构体传递, 而只使用了其中 16 个 field.
  - 可以考虑将结构体再细分成多个子结构体
- 控制耦合: A -> B 传递控制标志, 决定打印月报表,季报表还是年报表
- 不可取全局耦合: 改动了全局变量
- 可取全局耦合: 只读全局变量

`子程序本来是用于降低复杂度的工具, 如果使用它没有使工作更简单, 那说明没有用他更好.`

### 5.5 子程序长度

- 小于 200 行: ok
- 大于 200 行: 小心注意了

修复成本也与行数有关

### 5.6 防错性编程

#### 5.6.7 使用"防火墙"包容错误带来的危害

在程序中构建防火墙的最好办法是吧某些接口标识成"安全"边界. 对穿越安全区边界的数据镜像合法性检查, 如果是非法的数据, 要对其进行消毒处理, 手术室中的一切都认为是无毒安全的.

最简单就是`在外部数据进入时进行消毒`

#### 5.6.9 在最终软件中保留多少防错性编程

- 去掉那些无关紧要错误的代码: `去掉`并不是指物理上去掉, 它指的是版本控制预编译开关.
- 如果不存在空间限制问题, 也可以保留这段查错代码, 并让它向 Error log 隐蔽地传递信息.
- 保证留在程序中的错误提示信息是友好的.
- 过多的防错性编程会带来它自身的问题.

### 5.7 子程序参数

- 约定: C语言中, 把被修改的参数放在`首位`
- 约定: 把`状态`和`错误`放在最后
- 没用上的参数就不要传
- 不要把传参当作 ( 临时变量 )使用
- 如果发现传递参数过多, 说明程序之间的耦合有写过于紧密了.
  - 这时候应重新设计子程序, 来降低耦合的紧密性.

## 6 模块化设计

### 6.1 模块的内聚与耦合

类似 5

### 6.2 信息屏蔽

#### 6.2.2 信息隐蔽举例

- 就是`private`和`public`, 如:

  ```rust
  // 1. 普通判断
  if node.next != nil {
    node = node.next;
  }

  // 2. 严谨判断
  if node != nil {
    if node.next != nil {
      node = node.next;
    }
  }

  // 3. 封装
  let node = NearestNeighbor(node);
  ```

  如果 `1.` 和 `2.` 在多处调用后再修改, 会很麻烦, 也容易被遗忘
  如果使用 `3.` 封装了以后, 只需要在封装内部修改就可以了

#### 6.2.3 常见需要隐含的信息

- 容易被改动的区域
  - 接口应该把变动限制在模块内部, 外部不会受到内部变动影响. 如:
    - 对硬件依赖的地方
    - 输入输出
    - 非标准语言特性(rust 的 Unsafe, WinApi 等)
    - 状态变量
      - 不要用`逻辑型变量`作为状态, 用`枚举型变量`

        ```rust
        // bad taste
        struct UserState {
          is_running: bool,
          is_resting: bool,
          is_sleeping: bool,
        }

        // good taste
        enum UserState{
          RUN
          REST
          SLEEP
        }
        ```

      - 用子程序进行`状态检查` (?)

    - 数据规模不要写死

      ```rust
      // bad taste
      if slices.len() > 15 { /* ... */ }

      // good taste
      const MAX_SLICES_LEN = 15
      if slices.len() > MAX_SLICES_LEN { /* ... */ }
      ```

    - 商业规则, 游戏规则: 单独写在一个地方
- 复杂的数据
- 复杂的逻辑
  - 只需要封装起来, 把结果暴露出来就好, 实现细节不必展示
- 程序语言上的操作
  
  ```rust
  // bad taste
  let employee_id = employee_id + 1;
  let current_employee = employee_vec[employee_id];

  // good taste
  let current_employee = next_available_employee(employee_list, employee_id);

  // (maybe) better taste
  let employee_struct = Employee::new();
  /* ... */
  let current_employee = employee_struct.next_available_employee(employee_id)
  ```

  ```rust
  // bad taste
  front_of_queue();
  back_of_queue();
  next_in_queue();
  // good taste
  highest_priority_event();
  lowest_priority_event();
  next_event();
  ```

#### 6.2.4 信息隐蔽的障碍

- 信息过度分散: 用全局(模块)变量
- 交叉依赖: 重构, 重新设计
- 误把模块数据当作全局数据
  - 一个子程序在对其进行操作时并不知道其它子程序也在对它进行操作
  - 这个子程序知道其它子程序也在对其进行操作, 但不知道它们对它干了什么
- 误认为会损失性能: 担心调用的性能损耗是不成熟的体现

### 6.3 建立模块的理由

面向对象

## 7 高级结构设计

### 7.1 软件设计

#### 7.1.2 软件设计的层次

子系统 1->N 子模块 1->N 子函数 -> 写实现

### 7.2 结构化设计

- 组成:
  - 系统组织: 系统被设计成几个黑盒子, 明确定义的子程序和模块, 接口的实现细节对其它子程序来说都是隐含的
  - 开发设计的策略
  - 评估设计准则
  - 关于问题的明确说明, 这是解决问题的指导原则
  - 表达设计的图形和语言工具, 包括 PDL 和结构图

#### 7.2.1 选择需要进行模块化的元素

- 自顶向下分解 -> 逐步求精
  - 主要子程序为顶 原则如下:
    - 设计高层次
    - 避免语言细节
    - 不指出下层的设计细节
    - 正规化每个层次
    - 检验每个层次
    - -> 转移到下一个层次, 重复动作 ↑
  - 多次分解, 并且试试看多种分解的可能性
  - 分解到什么程度? 知道下一步进行编码要比再分解要简单为止
- 自底向上合成
  - 原则:
    - 系统要做什么你知道哪些
    - 利用这一问题识别出某些低层次功能
    - 识别出这些层次功能共同的方面, 将其组合到一起
    - 向上一个层次, 进行同样的工作, 或回到顶端开始自顶向下

各有优缺点, 自己看情况使用

### 7.3 面向对象

dddd

### 7.4 各种设计方法的对比

1000 行以上 , 面向对象好
以下, 结构体足矣

### 7.5 往返设计

写完一次, 再写一次

在从事`低层次问题`时所获得的细节将为你`高层次的总体理解`和`作出总体设计决定`奠定下良好的基础, 这种高低层次间往返思维过程是非常有益的

#### 7.5.2 设计是个复杂的过程

说它是个复杂的过程也是因为你不知道什么时候设计方案已经足够完善了. 什么时候算完成呢? 对这个问题的通常答案是 "当你没有时间时"

#### 7.5.3 设计是个险恶的过程

怎么说? 因为很多时候, 我们需要先"解决"问题后, 才能有一个清除的定义和理解, 然后再重新解决一遍, 以获得正确的方法.

#### 7.5.4 设计是一个启发的过程

- 启发: 吃一堑, 长一智
- 最重要的设计原则之一是不要死抱着一种方法不放
  - `写PDL`, `作图`, `伪代码`, `写小程序验证`...
  - 或者用完全不同的方法: 暴力算法, 铅笔不停写和画...
  - 如果都没效果, 暂时放开这个问题, 出去自由自在地散步, 或者想一下别的, 然后再回到这个问题上.
  - 实在解决不了, 就暂时不考虑这个问题了...

#### 7.5.5 受欢迎的设计特点

- 智力的上可管理
- 低复杂度
- 维护方便
- 最小联系性: 保持子程序之间的联系最少的原则来设计
  - 以`强内聚`, `松散耦合`, `信息隐蔽`作为编码原则
- 可扩充: 功能变动时, 越不需要改动, 则表示代码的可扩充性越强
- 可重复使用性: 抽象成别的程序可以用的
- 高扇入: 对一个给定的子程序, 被调用的越频繁就越高扇入
- 低扇出: 对一个给定的子程序, 其调用的子程序越少就越低扇出
  - 但不是越低越好, 7 个以内都可以接受吧
- 可移植性
- 简练性: 最有害的观点是"多加入些又不会有害, 怕什么呢"
- 成层设计: 尽量分解的层次是成层的, 这样可以在每一个单独的层次上观察系统
  - 如果不得不借用许多旧的, 设计得不好的代码, 那可以在新的系统中建立一个层, 让它与旧代码连接, 把缺点隐含起来.
- 标准化技术

## 8 生成数据

### 8.2 自建数据类型的原因

```rust
// type 1
struct ForXYPlot(f64);
impl ForXYPlot {
  //...
}

// type 2
const MAX_SLICES_LEN = 15;
let employee_id = &str[0..MAX_SLICES_LEN];
```

- 使得改动更加容易
- 避免过度分散的信息分布
- 为了增加可靠性
- 补偿语言的弱点

### 8.3 自建数据类型的准则

- 建立具有面向功能名称的类型
- 避免使用含有已定义变量类型的名称
- 避免使用已定义类型
- 定义替换类型以增强移植性
  - type INT = i64 / i32 : 64位系统是i64, 32位系统是 i32

### 8.5 初始化数据的准则

- 子程序的输入是否都有效?
- 是否在使用变量的位置附近进行了初始化?
- 是否恰当的对计数器和指针进行了初始化, 是否必要时对其进行重新初始化?
- 在反复执行的代码段中, 是否对变量进行了恰当地初始化?
- 编译是否有警告(现代编程语言基本有做了)?

## 9 数据名称

### 9.1 选名


