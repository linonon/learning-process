
# DDIA

[书籍位置](https://github.com/Vonng/ddia)

[TOC]

## 第一部分

### 第一章 可靠性, 可伸缩性, 可维护性

- `数据密集型程序` 多, `计算密集型程序` 少

数据密集型常有组件:

- 存储数据
- 缓存
- 关键字搜索
- 异步处理
- 批处理 (batch processing)

因为不同的需求, 所以数据库系统也是百花齐放, 各有各的特性

- 数据库和消息列表表面上都有相似性: 存储一段时间的数据, 但他们是完全不一样的东西

本书着重讨论三个问题:

- 可靠性
  - 系统在困境中(硬件故障, 软件故障, 人为错误)仍可正常工作
- 可伸缩性
  - 有合理的办法应对系统的增长(数据量, 流量, 复杂性)
- 可维护性
  - 许多不同的人都能高效的在系统上工作

#### 可靠性

定义

- 功能正常
- 错误处理正常
- 性能满足需求
- 系统能防止未经授权的访问和滥用

错误处理

- 故障: 造成错误的原因
- 容错: 能预料并应对故障的系统特性
- 设计容错机制: 防止因`故障`而导致`失效`

容错系统

- 我们可以通过`故意引发故障`来确保容错机制不断运行并接受考验

##### 硬件故障

- 硬盘, 内存, 电源, 网线等出问题了
- 硬盘无故障时间: 10 ~ 15 年
  - 数学期望解释: 10,000 个磁盘的存储集群, 每天会有一个出故障
- 增加硬件冗余度已避免问题发生

##### 软件错误

系统性错误:

- 接受特定的错误输入
- 失控进程用尽了一些共享资源(CPU, 内存, 磁盘, 网络等)
- 系统依赖的服务没有响应
- 级联错误

虽然不能立刻解决, 但是也有小办法:

- 仔细思考系统中的假设和交互
- 彻底的测试
- 进程隔离
- 允许进程崩溃并重启
- 测试, 监控并分析生产环境中的系统行为

##### 人为错误

即使人类怀着最大的善意, 人类也是不可靠的

怎么办?

- 以最小化犯错机会的方式设计系统
- 把`容易犯错的地方`或`可能导致失效的地方`解耦
- 彻底的测试, 包括边缘场景
- 允许从人为错误中简单快速地恢复(快速回滚, 灰度发布)
- 配置详细和明确的`监控`, 比如性能指标和错误率
- 良好的管理时间与充分的培训

##### 可靠性有多重要?

很重要, 但当然, 如果你做的是不重要的原型, 可以牺牲可靠性来降低开发成本

#### 可伸缩性

需要考虑:

- 如果系统以特性方式增长, 有什么可以应对增长
- 如何增加计算资源来处理额外的负载
- ...

##### 描述负载

负载参数:

- 每秒向服务器发出的请求
- 数据库中的读写比
- 聊天室中同时活跃的用户数量
- 缓存命中率
- ...

推特为例

- 最大问题: 扇出 (fan-out) -- 关注与被关注者的推文关系
- 最终解决方法: 普通人用写入时间线的方法, 明星用读取时间线的方法

##### 描述性能

研究复杂增加

- 增加负载参数并保持系统资源不变, 系统性能将受到什么影响?
- 增加负载参数并希望保持性能不变时, 需要增加多少系统资源?

如何描述系统性能

- 响应时间: 客户端`发送请求到接收相应`之间的时间
  - 影响因素:
    - 上下文切换
    - 网络丢包和 TCP 重传
    - GC 暂停
    - 磁盘读取错误
  - 时间分类:
    - 平均值
    - 中位数
    - 百分位点(percentiles): 95th, 99th, ...

百分位点

- 常用于`服务级别目标(SLO, service level objectives)`和`服务级别协议(SLA, service level agreements)`

排队延迟

- 头部阻塞: 前面的请求慢了, 后面的再快也得等

##### 应对负载的方法

伸缩方式

- 纵向伸缩(scaling up, 垂直伸缩, vertical scaling)
- 横向伸缩(scaling out, 水平伸缩, horizontal scaling)

伸缩类型

- 弹性伸缩: 更有用
- 手动伸缩: 更简单

有/无状态服务

- 无状态服务
  - 部署简单
- 有状态服务
  - 数据库应放在单节点(纵向伸缩)
  - 直到成本与可用性需求迫使其改为分布式

分布式系统

- 随着分布式系统部署越来越简单, 在未来可能是数据系统的默认设置
- 没有万金油(magic scaling sauce)
- 应用的问题: 读取量, 写入量, 存储的数据量, 数据复杂度, 相应时间要求, 访问模式或者所有问题的大杂烩

##### 可维护性

- 避免系统编程遗留系统, 我们需要关注`三个设计原则`
  - 可操作性: 便于运维团队保持系统平稳运行
  - 简单性: 从系统中消除尽可能多的复杂度, 使新工程师也能轻松理解系统
  - 可修改性: 使工程师未来也能轻松地对系统进行修改

优秀运维的典型职责

- 监控系统的运行状况, 服务状态不佳时能快速恢复服务
- 跟踪问题原因
- 及时更新软件和平台
- 了解系统间的相互作用
- 预测未来的问题
- 建立部署, 配置, 管理方面的良好实践
- 执行复杂的维护任务: 将一个应用程序用一个平台迁移到另一个平台
- 配置变更时, 维持系统的安全性
- 定义工作流程, 使运维操作可预测, 并保持生产环境稳定
- 维持组织对系统的了解

日常管理数据系统的优化

- 提供系统内部`可见性`的监控
- 良好的自动化支持
- 避免依赖单台机器
- 提供良好的默认行为
- 有条件时进行自我修复
- 确保行为可预测

##### 简单性: 管理复杂度

- 复杂度提升 -> 维护困难
- `简单性`应该是构建系统的一个`关键目标`
- `简单性`不意味着一定要减少功能, 也可以表示`减少额外的复杂度`
- `减少额外复杂度`的最好工具之一: 抽象
- 本书将紧盯那些允许我们将大型系统的部分提取为`定义明确的`, `可重用的`组件的`优秀抽象`

##### 可修改性: 拥抱变化

敏捷

- 测试驱动开发
- 重构
- 修改数据系统使其适应不断变化需求的容易程度

### 第二章: 数据模型与查询语言

每层数据模型的关键问题: 它是如何用低一层数据模型来表示的?

- 基本思想基本一样: 每层都通过提供一个`明确的数据模型`来隐藏更低层次中的复杂性, 这些抽象允许不同的人群有效地协作

#### 关系模型和文档模型

- 关系模型: SQL
- 文档模型: NoSQL

关系数据库可能会继续和各种非关系数据库一起使用 -- `混合持久化`

##### 对象关系不匹配

模型之间的不连贯有时被称作为: 阻抗不匹配
